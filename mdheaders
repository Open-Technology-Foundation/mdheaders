#!/bin/bash
# mdheaders - Manipulate markdown header levels while preserving code blocks
# https://github.com/Open-Technology-Foundation/mdheaders
# License: GPL-3.0

set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

# Script Metadata
declare -r VERSION='1.2.0'
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -e -- "$0")
#shellcheck disable=SC2034  # SCRIPT_DIR reserved for future use
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

declare -i VERBOSE=1

# Standard colors - only if terminal output
if [[ -t 1 && -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

# Core message function using FUNCNAME for context
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  case "${FUNCNAME[1]}" in
    success) prefix+=" ${GREEN}✓${NC}" ;;
    warn)    prefix+=" ${YELLOW}▲${NC}" ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

# Conditional output based on verbosity
success() { ((VERBOSE)) || return 0; _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }

# Unconditional output
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

# Validate option has argument
noarg() { (($# > 1)) || die 2 "Option ${1@Q} requires an argument"; }

# English pluralizer - outputs 's' unless count is 1
# Usage: "file$(s "${#files[@]}")" → "file" or "files"
s() { (( ${1:-1} == 1 )) || echo -n 's'; }

# Process markdown content and modify header levels
# Args:
#   $1: delta (positive=upgrade, negative=downgrade)
#   $2: error mode ("skip" or "stop")
#   $3: quiet mode (0=verbose, 1=quiet)
# Input: markdown content via stdin
# Output: modified markdown to stdout
# Returns: 0 on success, 1 on error
mdh_process() {
  local -i delta=$1
  local -- error_mode="${2:-skip}"
  local -i quiet="${3:-0}"

  local -i in_code_block=0
  local -- fence_type=''
  local -- line fence_regex close_regex hashes rest new_hashes
  local -i modified=0 skipped=0 line_num=0 current_level new_level

  fence_regex='^[[:space:]]*(```|~~~)'

  while IFS= read -r line; do
    line_num+=1

    # Check for code fence toggle (``` or ~~~)
    if [[ "$line" =~ $fence_regex ]]; then
      if ((in_code_block)); then
        # Check if closing fence matches opening type
        close_regex="^[[:space:]]*${fence_type}"
        if [[ "$line" =~ $close_regex ]]; then
          in_code_block=0
          fence_type=''
        fi
      else
        # Opening fence
        in_code_block=1
        fence_type="${BASH_REMATCH[1]}"
      fi
      printf '%s\n' "$line"
      continue
    fi

    # Process headers only when NOT in code block
    if ((in_code_block == 0)) && [[ "$line" =~ ^(#+)([[:space:]]+.*)?$ ]]; then
      hashes="${BASH_REMATCH[1]}"
      rest="${BASH_REMATCH[2]}"
      current_level=${#hashes}
      new_level=$((current_level + delta))

      # Validate new level (H1=1 to H6=6)
      if ((new_level < 1)); then
        skipped+=1
        if ((quiet == 0)); then
          warn "Line $line_num: Cannot downgrade H$current_level (already at minimum)"
        fi
        if [[ "$error_mode" == "stop" ]]; then
          return 1
        fi
        printf '%s\n' "$line"
      elif ((new_level > 6)); then
        skipped+=1
        if ((quiet == 0)); then
          warn "Line $line_num: Cannot upgrade H$current_level (already at maximum)"
        fi
        if [[ "$error_mode" == stop ]]; then
          return 1
        fi
        printf '%s\n' "$line"
      else
        # Create new header with adjusted level
        printf -v new_hashes '%*s' "$new_level" ''
        new_hashes=${new_hashes// /#}
        printf '%s%s\n' "$new_hashes" "$rest"
        modified+=1
      fi
    else
      # Not a header or inside code block - output as-is
      printf '%s\n' "$line"
    fi
  done

  # Warn if file ended with unclosed code block
  if ((in_code_block && quiet == 0)); then
    warn 'File ended with unclosed code block'
  fi

  # Report summary
  if ((quiet == 0 && (modified > 0 || skipped > 0))); then
    info "Processed $modified header$(s "$modified"), skipped $skipped"
  fi

  # Return success if we modified anything, or if nothing needed modification
  ((skipped > 0 && modified == 0)) && return 1
  return 0
}

# mdh_upgrade - Increase header levels (# → ##, ## → ###, etc.)
# Args:
#   $1: levels - Number of levels to increase (default: 1)
#   $2: error_mode - "skip" to continue on boundary errors, "stop" to abort (default: skip)
#   $3: quiet - 0 for verbose output, 1 for quiet (default: 0)
# Input: markdown content via stdin
# Output: transformed markdown to stdout
# Returns: 0 on success, 1 if all headers skipped or error
mdh_upgrade() {
  local -i levels="${1:-1}"
  local -- error_mode="${2:-skip}"
  local -i quiet="${3:-0}"

  if ((levels < 1)); then
    error 'Upgrade levels must be >= 1'
    return 1
  fi

  mdh_process "$levels" "$error_mode" "$quiet"
}

# mdh_downgrade - Decrease header levels (## → #, ### → ##, etc.)
# Args:
#   $1: levels - Number of levels to decrease (default: 1)
#   $2: error_mode - "skip" to continue on boundary errors, "stop" to abort (default: skip)
#   $3: quiet - 0 for verbose output, 1 for quiet (default: 0)
# Input: markdown content via stdin
# Output: transformed markdown to stdout
# Returns: 0 on success, 1 if all headers skipped or error
mdh_downgrade() {
  local -i levels="${1:-1}"
  local -- error_mode="${2:-skip}"
  local -i quiet="${3:-0}"

  if ((levels < 1)); then
    error 'Downgrade levels must be >= 1'
    return 1
  fi

  mdh_process "-$levels" "$error_mode" "$quiet"
}

# mdh_detect_min_level - Find the smallest header level in a document
# Scans document while respecting code block boundaries.
# Input: markdown content via stdin
# Output: minimum header level (1-6) to stdout
# Returns: 0 if headers found, 1 if no headers in document
mdh_detect_min_level() {
  local -i in_code_block=0 min_level=7 level
  local -- fence_type="" line fence_regex close_regex hashes

  fence_regex='^[[:space:]]*(```|~~~)'

  while IFS= read -r line; do
    # Check for code fence toggle
    if [[ "$line" =~ $fence_regex ]]; then
      if ((in_code_block)); then
        close_regex="^[[:space:]]*${fence_type}"
        if [[ "$line" =~ $close_regex ]]; then
          in_code_block=0
          fence_type=""
        fi
      else
        in_code_block=1
        fence_type="${BASH_REMATCH[1]}"
      fi
      continue
    fi

    # Check for headers only when NOT in code block
    if ((in_code_block == 0)) && [[ "$line" =~ ^(#+)([[:space:]]+.*)?$ ]]; then
      hashes="${BASH_REMATCH[1]}"
      level=${#hashes}
      ((level < min_level)) && min_level=$level
    fi
  done

  # Return error if no headers found
  if ((min_level == 7)); then
    return 1
  fi

  printf '%d' "$min_level"
  return 0
}

# mdh_normalize - Adjust all headers so minimum level matches target
# Uses two-pass algorithm: first detects current minimum, then shifts all headers.
# Example: If doc has H1,H2,H3 and target=2, result is H2,H3,H4.
# Args:
#   $1: target_level - Desired minimum header level, 1-6 (default: 1)
#   $2: error_mode - "skip" to continue on boundary errors, "stop" to abort (default: skip)
#   $3: quiet - 0 for verbose output, 1 for quiet (default: 0)
# Input: markdown content via stdin
# Output: normalized markdown to stdout
# Returns: 0 on success, 1 if no headers found or all skipped
mdh_normalize() {
  local -i target_level="${1:-1}"
  local -- error_mode="${2:-skip}"
  local -i quiet="${3:-0}"

  # Validate target level
  if ((target_level < 1 || target_level > 6)); then
    error 'Target level must be between 1 and 6'
    return 1
  fi

  # Store stdin to temp file so we can read it twice
  local -- temp_content
  temp_content=$(mktemp) || {
    error 'Failed to create temporary file'
    return 1
  }
  trap 'rm -f "${temp_content:-}"' RETURN

  # Read all input to temp file
  cat > "$temp_content"

  # First pass: detect minimum level
  local -i min_level delta
  if ! min_level=$(mdh_detect_min_level < "$temp_content"); then
    error 'No headers found in document'
    rm -f "$temp_content"
    return 1
  fi

  # Calculate delta needed
  delta=$((target_level - min_level))

  # Report what we're doing
  if ((quiet == 0)); then
    info "Detected minimum level: H$min_level, target: H$target_level, delta: $delta"
  fi

  # If already at target, just output as-is
  if ((delta == 0)); then
    if ((quiet == 0)); then
      info "Document already normalized to H$target_level"
    fi
    cat "$temp_content"
    rm -f "$temp_content"
    return 0
  fi

  # Second pass: apply delta
  mdh_process "$delta" "$error_mode" "$quiet" < "$temp_content"
  local result=$?

  rm -f "$temp_content"
  return "$result"
}

# show_usage - Display help text
show_usage() {
  cat <<'EOF'
Usage: mdheaders {upgrade|downgrade|normalize|up|down|norm} [OPTIONS] FILE

Manipulate markdown header levels while preserving code blocks.

Commands:
  upgrade, up         Increase header levels (# → ##)
  downgrade, down     Decrease header levels (## → #)
  normalize, norm     Auto-adjust all headers to start at target level

Options:
  -l, --levels=N         Number of levels to shift (default: 1)
  -s, --start-level=N    Target starting level for normalize (default: 1)
  -o, --output=FILE      Output file (default: stdout)
  -i, --in-place         Modify file in-place
  -b, --backup[=SUFFIX]  Create backup before in-place edit (default: .bak)
  --skip-errors          Skip invalid headers with warning (default)
  --stop-on-error        Abort on first invalid header
  -q, --quiet            Suppress warnings and progress messages
  -v, --verbose          Show detailed processing information
  -V, --version          Show version
  -h, --help             Show this help message

Examples:
  mdheaders up README.md              # Upgrade headers by 1 level
  mdheaders down -ib doc.md           # Downgrade in-place with backup
  mdheaders up -l 2 -o NEW.md OLD.md  # Upgrade by 2, save to new file
  mdheaders norm -s 2 README.md       # Normalize to start at H2

Behavior:
  - Fenced code blocks (``` and ~~~) are preserved; headers inside are not modified
  - Headers cannot go below H1 (#) or above H6 (######)
  - The normalize command uses two passes: detect minimum, then shift all headers

Exit codes:
  0  Success
  1  Error or all headers skipped
  2  Invalid arguments

More info: https://github.com/Open-Technology-Foundation/mdheaders
EOF
}

# Main function
main() {
  # Default values
  local -- command=''
  local -i levels=1
  local -i start_level=1
  local -- output_file=''
  local -i in_place=0
  local -- backup_suffix=''
  local -- error_mode='skip'
  local -i quiet=0
  local -- input_file=''

  # Parse command
  if (($# == 0)); then
    show_usage
    return 2
  fi

  case $1 in
    upgrade|up)
      command='upgrade'
      shift
      ;;
    downgrade|down)
      command='downgrade'
      shift
      ;;
    normalize|norm)
      command='normalize'
      shift
      ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"; return 0
      ;;
    -h|--help|help)
      show_usage; return 0
      ;;
    *)
      die 2 "Unknown command ${1@Q}" 'Use --help for usage information'
      ;;
  esac

  # Parse options
  while (($#)); do case $1 in
    -l|--levels)
      noarg "$@"; shift; levels="$1"
      ;;
    --levels=*)
      levels="${1#*=}"
      ;;
    -s|--start-level)
      noarg "$@"; shift; start_level="$1"
      ;;
    --start-level=*)
      start_level="${1#*=}"
      ;;
    -o|--output)
      noarg "$@"; shift; output_file="$1"
      ;;
    --output=*)
      output_file="${1#*=}"
      ;;
    -i|--in-place)
      in_place=1
      ;;
    -b|--backup)
      backup_suffix='.bak'
      ;;
    --backup=*)
      backup_suffix="${1#*=}"
      ;;
    --skip-errors)
      error_mode='skip'
      ;;
    --stop-on-error)
      error_mode='stop'
      ;;
    -q|--quiet)
      quiet=1
      ;;
    -v|--verbose)
      quiet=0
      ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"; exit 0
      ;;
    -h|--help)
      show_usage; return 0
      ;;
    -[ibqvVh]*) #shellcheck disable=SC2046 #split up bundled short options
      set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
      ;;
    -*)
      die 2 "Unknown option ${1@Q}"
      ;;
    '')
      # Skip empty argument from option bundling
      ;;
    *)
      if [[ -z "$input_file" ]]; then
        input_file="$1"
      else
        die 2 "Multiple input files specified ${1@Q}"
      fi
      ;;
  esac; shift; done

  # Validate arguments
  [[ -n "$input_file" ]] || die 2 'No input file specified'
  [[ -f "$input_file" ]] || die 1 "File not found ${input_file@Q}"
  ((levels >= 1)) || die 2 'Levels must be >= 1'
  ((in_place && ${#output_file} > 0)) && die 2 'Cannot use both --in-place and --output'

  # Create backup if requested and doing in-place edit
  if ((in_place && ${#backup_suffix} > 0)); then
    local -- backup_file="${input_file}${backup_suffix}"
    cp "$input_file" "$backup_file" || die 1 'Failed to create backup file'
    ((quiet)) || info "Created backup ${backup_file@Q}"
  fi

  # Process the file
  local -- temp_file=""
  temp_file=$(mktemp) || die 1 'Failed to create temporary file'
  trap 'rm -f "${temp_file:-}"' EXIT

  local -i result=0
  if [[ "$command" == "upgrade" ]]; then
    mdh_upgrade "$levels" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  elif [[ "$command" == "downgrade" ]]; then
    mdh_downgrade "$levels" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  elif [[ "$command" == "normalize" ]]; then
    mdh_normalize "$start_level" "$error_mode" "$quiet" < "$input_file" > "$temp_file" || result=$?
  fi

  # Handle output
  if ((result == 0)); then
    if ((in_place)); then
      mv "$temp_file" "$input_file" || die 1 "Failed to write output file ${input_file@Q}"
      ((quiet)) || info "Modified ${input_file@Q} in-place"
    elif [[ -n "$output_file" ]]; then
      mv "$temp_file" "$output_file" || die 1 "Failed to write output file ${output_file@Q}"
      ((quiet)) || info "Wrote output to ${output_file@Q}"
    else
      cat "$temp_file"
    fi
  fi

  return "$result"
}

main "$@"
#fin
